#!/bin/sh
#
# Hooks to add custom options to the configure script.
#

plugin_usage()
{
    : # Do nothing
#    cat <<EOF
#    --with-foo=DIR          Path to foo
# EOF
}

plugin_option()
{
    case "$1" in
#        --with-foo=*)
#            append_cache_entry FOO_DIR PATH $optarg
#            return 0
#            ;;

        *)
            return 1;
            ;;
    esac
}

# Community ID needs two bits of information for reasonably portable
# builds: (1) whether the Zeek installation has "old" or "new" digest
# functions, (2) whether the digest functions are in the zeek::detail
# namespace. --cpk

find_digest_header()
{
    paths="$1"

    # Split on : and check each path for a digest.h, with or without
    # additional zeek directory (4.1 no longer explicitly mentions
    # that directory). For portability, loosely based on
    # https://unix.stackexchange.com/a/64173
    (
	IFS=:
	for dir in $paths; do
            [ ! -d "$dir" ] && continue
            if [ -f "$dir/digest.h" ]; then
		echo "$dir/digest.h"
		break
            elif [ -f "$dir/zeek/digest.h" ]; then
		echo "$dir/zeek/digest.h"
		break
            fi
	done
    )
}

is_in_detail_namespace()
{
    header="$1"
    grep -q zeek::detail "$header" 2>&1
}

plugin_addl()
{
    is_namespaced=false

    if [ -n "$zeekdist" ] && [ -f "$zeekdist/src/digest.h" ]; then
        header="$zeekdist/src/digest.h"
    elif command -v zeek-config >/dev/null 2>&1; then
        paths="$(zeek-config --include_dir)"
        header="$(find_digest_header "$paths")"
    fi

    if [ -n "$header" ] && is_in_detail_namespace "$header"; then
        is_namespaced=true
    fi

    append_cache_entry ZEEK_HAS_NAMESPACED_DIGEST BOOL $is_namespaced

    echo "digest.h location      : $header"
    echo "Namespaced functions   : $is_namespaced"
}
